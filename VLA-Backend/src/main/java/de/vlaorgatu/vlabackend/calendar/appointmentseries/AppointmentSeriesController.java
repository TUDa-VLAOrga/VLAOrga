package de.vlaorgatu.vlabackend.calendar.appointmentseries;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;

import de.vlaorgatu.vlabackend.sse.SseController;
import java.util.Objects;
import java.util.Optional;
import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.springframework.data.rest.webmvc.RepositoryRestController;
import org.springframework.hateoas.EntityModel;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * Overrides to the default REST handlers generated by Spring Data REST.
 * <br>
 * Mainly needed to trigger SSE events on update operations.
 */
@AllArgsConstructor
@RepositoryRestController
public class AppointmentSeriesController {
    private static final Logger LOGGER =
        org.slf4j.LoggerFactory.getLogger(AppointmentSeriesController.class);
    private final AppointmentSeriesRepository appointmentSeriesRepository;

    /**
     * Creates a new appointment series.
     *
     * @param appointmentSeries The dataset for creation. Must not contain an ID.
     * @return OK response with the created appointment series, Error response otherwise.
     */
    @PostMapping("/appointmentSeries")
    public ResponseEntity<?> createAppointmentSeries(
        @RequestBody AppointmentSeries appointmentSeries) {
        if (Objects.nonNull(appointmentSeries.getId())) {
            LOGGER.info(
                "Received appointment series with ID {} when creating a new appointment series.",
                appointmentSeries.getId());
            return ResponseEntity.badRequest().build();
        }

        AppointmentSeries saved = appointmentSeriesRepository.save(appointmentSeries);
        // TODO: use a better method here instead of debug message
        SseController.notifyDebugTest("Appointment series created: " + saved);

        EntityModel<AppointmentSeries> entityModel = EntityModel.of(saved, linkTo(
            methodOn(AppointmentSeriesController.class).updateAppointmentSeries(saved.getId(),
                saved)).withSelfRel());
        return ResponseEntity.ok(entityModel);
    }

    /**
     * Updates an existing appointment series.
     *
     * @param id                ID of the appointment series to update.
     * @param appointmentSeries Dataset of the appointment series to update.
     *                          Must contain all keys, ID may be omitted.
     * @return OK response with the updated appointment series, Error response otherwise.
     */
    @PutMapping("/appointmentSeries/{id}")
    public ResponseEntity<?> updateAppointmentSeries(
        @PathVariable Long id, @RequestBody AppointmentSeries appointmentSeries) {
        if (Objects.isNull(appointmentSeries.getId())) {
            appointmentSeries.setId(id);
        } else if (!appointmentSeries.getId().equals(id)) {
            LOGGER.warn("Received inconsistent IDs on appointment series update");
            return ResponseEntity.badRequest().build();
        }
        if (!appointmentSeriesRepository.existsById(id)) {
            LOGGER.warn("Received appointment series update for non-existing" +
                " appointment series with ID {}.", id);
            return ResponseEntity.notFound().build();
        }

        AppointmentSeries updated = appointmentSeriesRepository.save(appointmentSeries);
        // TODO: use a better method here instead of debug message
        EntityModel<AppointmentSeries> entityModel = EntityModel.of(updated, linkTo(
            methodOn(AppointmentSeriesController.class).updateAppointmentSeries(id,
                updated)).withSelfRel());
        return ResponseEntity.ok(entityModel);
    }

    /**
     * Deletes an appointment series by its ID.
     *
     * @param id ID of the appointment series to delete.
     * @return OK response with the deleted dataset.
     */
    @DeleteMapping("/appointmentSeries/{id}")
    public ResponseEntity<?> deleteAppointmentSeries(@PathVariable Long id) {
        Optional<AppointmentSeries> appointmentSeriesOptional =
            appointmentSeriesRepository.findById(id);
        if (appointmentSeriesOptional.isEmpty()) {
            LOGGER.warn("Received appointment series deletion for non-existing" +
                " appointment series with ID {}.", id);
            return ResponseEntity.notFound().build();
        }

        appointmentSeriesRepository.deleteById(id);
        // TODO: use a better method here instead of debug message
        SseController.notifyDebugTest("Appointment series deleted: " + id);

        EntityModel<AppointmentSeries> entityModel = EntityModel.of(appointmentSeriesOptional.get(),
            linkTo(methodOn(AppointmentSeriesController.class).deleteAppointmentSeries(
                id)).withSelfRel());
        return ResponseEntity.ok(entityModel);
    }
}
